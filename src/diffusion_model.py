from abc import abstractmethod
import torch
import torch.nn as nn

class TimeEmbedding(nn.Module):
    def __init__(self):
        super().__init__()

    @abstractmethod
    def forward(self, t: torch.Tensor) -> torch.Tensor:
        """
        Forward pass for time embedding.

        Args:
            t (torch.Tensor): Time step tensor.

        Returns:
            torch.Tensor: Embedded time tensor.
        """
        pass

class DenoisingModel(nn.Module):
    def __init__(self):
        super().__init__()
    
    @abstractmethod
    def forward(self, x: torch.Tensor, t_emb: torch.Tensor) -> torch.Tensor:
        """
        Forward pass of the denoising model.

        Args:
            x (torch.Tensor): Input tensor.
            t_emb (torch.Tensor): Time embedding tensor.

        Returns:
            torch.Tensor: Output tensor after applying the denoising process.
        """
        pass

class DiffusionModel(nn.Module):
    def __init__(self, denoising_model: DenoisingModel, embedding_model: TimeEmbedding, input_shape: tuple, num_timesteps: int = 1000):
        super().__init__()
        self.denoising_model = denoising_model
        self.embedding_model = embedding_model

        self.input_shape = input_shape
        self.num_timesteps = num_timesteps
    
    def forward(self, x: torch.Tensor, t: torch.Tensor) -> torch.Tensor:
        """
        Forward pass of the diffusion model (denoise process).

        Args:
            x (torch.Tensor): Input tensor.
            t (torch.Tensor): Time step tensor.

        Returns:
            torch.Tensor: Output tensor after applying the diffusion process.
        """
        with torch.no_grad():
            t_emb = self.embedding_model(t)
        return self.denoising_model(x, t_emb)

    def sample(self, num_samples: int) -> torch.Tensor:
        """
        Generate samples from the diffusion model.

        Args:
            num_samples (int): amount of samples to generate.

        Returns:
            torch.Tensor: images generated by the diffusion model. [num_samples, *input_shape]
        """
        initial_noise = torch.randn(num_samples, *self.input_shape)
        samples = initial_noise
        for t in range(self.num_timesteps, 0, -1):
            t_tensor = torch.full((num_samples,), t, device=samples.device, dtype=torch.long)
            samples = self.forward(samples, t_tensor)
        return samples
